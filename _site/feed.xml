<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>四木成森</title>
    <description>李森|不仅仅是一个程序员</description>
    <link>http://lisentoday/</link>
    <atom:link href="http://lisentoday/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 21 Apr 2016 00:54:36 -0400</pubDate>
    <lastBuildDate>Thu, 21 Apr 2016 00:54:36 -0400</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Leetcode Problem 338 Summary</title>
        <description>&lt;p&gt;#题目&lt;/p&gt;

&lt;p&gt;输入是一个非负整数num，输出从0到num的每个数的二进制表示有多少个1，输出一个长度为num+1的int数组，其中存放着每个二进制数的1的个数。要求算法复杂度O(n)&lt;/p&gt;

&lt;p&gt;#算法&lt;/p&gt;

&lt;p&gt;对每个数求1的个数然后求num+1次是最简单的方法，算法复杂度是O(n*sizeof(1+2+…+num+1))。要达到O(n)的算法复杂度，仔细思考有两种可能性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对每个数求二进制有多少个1存在O(1)的算法&lt;/li&gt;
  &lt;li&gt;后面的二进制有多少个1能根据前面已经求出来的计算而得，也就是动态规划算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种可能性基本排除，因为直觉感觉不可能，所以显然要用动态规划算法。得到递推公式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result[i] = result[i &amp;amp; (i - 1)] + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;i &amp;amp; (i - 1)是bit manipulation常用手段，得到的是i去掉最后一位1的结果，这个结果比i小，所以之前必然已经计算得出结果，而这两个数相差1的个数则是1，所以加1得到i的二进制表示中所含1的个数。&lt;/p&gt;

&lt;p&gt;#代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
	public int[] countBits(int num) {
    	int[] result = new int[num + 1];
    	result[0] = 0;
    	for (int i = 1; i &amp;lt;= num; i++) {
        	result[i] = result[i&amp;amp;(i-1)] + 1;
    	}
    	return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 20 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/20/Leetcode-338-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/20/Leetcode-338-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode Problem 225 Summary</title>
        <description>&lt;p&gt;#题目&lt;/p&gt;

&lt;p&gt;使用Queue数据结构实现Stack数据结构&lt;/p&gt;

&lt;p&gt;#算法&lt;/p&gt;

&lt;p&gt;使用一个Queue，每次push操作依次将首部的元素放到尾部，直到新添加的元素到首部。其它操作不变。&lt;/p&gt;

&lt;p&gt;#代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyStack {
	private Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();

	// Push element x onto stack.
	public void push(int x) {
    	queue.offer(new Integer(x));
    	for (int i = 0; i &amp;lt; queue.size() - 1; i++) {
        	queue.offer(queue.poll());
    	}
	}

	// Removes the element on top of the stack.
	public void pop() {
    	queue.poll();
	}

	// Get the top element.
	public int top() {
    	return queue.peek().intValue();
	}

	// Return whether the stack is empty.
	public boolean empty() {
    	return queue.isEmpty();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/19/Leetcode-225-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/19/Leetcode-225-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode Problem 1 Summary</title>
        <description>&lt;p&gt;#题目&lt;/p&gt;

&lt;p&gt;给一个int array和一个target值，数组中有两个数加和为target，返回这两个数的下标。&lt;/p&gt;

&lt;p&gt;#算法&lt;/p&gt;

&lt;p&gt;最开始的想法是用另一个数组储存排序后的原数组，排序后的数组从两头找，比target大就high–，比target小就low++，找到后再在原数组中找这两个数的下标。这种方法可以，但之后还需处理边界条件，如target由两个相同的数组成，则需要处理边界条件。&lt;/p&gt;

&lt;p&gt;相比较而言是用HashMap的方法更加简单，不用处理边界条件，key为nums[i]，value为index，只需要查看HashMap是否含有target-nums[i]，如果有，说明找到两个数。&lt;/p&gt;

&lt;p&gt;#代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
	public int[] twoSum(int[] nums, int target) {
	int[] result = new int[2];
    	Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
    	for (int i = 0; i &amp;lt; nums.length; i++) {
    		if (map.containsKey(new Integer(target - nums[i]))) {
           		result[1] = i;
           		result[0] = map.get(new Integer(target - nums[i]));
           		break;
       		} else {
            	map.put(new Integer(nums[i]), new Integer(i));
        	}
    	}
    	return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/19/Leetcode-1-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/19/Leetcode-1-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode Problem 342 Summary</title>
        <description>&lt;p&gt;#题目&lt;/p&gt;

&lt;p&gt;在不使用循环语句的情况下如何判断一个数是4的n次方。&lt;/p&gt;

&lt;p&gt;#算法&lt;/p&gt;

&lt;p&gt;首先想到是进行位操作，因为不能使用循环语句。4的n次方的特点是这个数同时也是2的2n次方，即0x55555555，所以需要num&amp;amp;0x55555555不为0。另外一个就是4的n次方的表示在32位数中只有一位是1，用num&amp;amp;(num-1)==0可以判断是否32位中只有一位是1。&lt;/p&gt;

&lt;p&gt;#代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
	public boolean isPowerOfFour(int num) {
    	return num &amp;gt; 0 &amp;amp;&amp;amp; (num&amp;amp;(num-1)) == 0 &amp;amp;&amp;amp; ((num&amp;amp;0x55555555) != 0);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 18 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/18/Leetcode-342-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/18/Leetcode-342-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Improving Programming Skills Plan</title>
        <description>&lt;p&gt;#Plan&lt;/p&gt;

&lt;p&gt;Carving out 20% of my time devote to my own skills development, one hour to two hour a day.&lt;/p&gt;

&lt;p&gt;#Things To Do&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reading and Implementing basic algorithm&lt;/li&gt;
  &lt;li&gt;learn how to efficiently using sublime text&lt;/li&gt;
  &lt;li&gt;Reading Java text book and developing a solid grasp of the advanced concepts in it&lt;/li&gt;
  &lt;li&gt;Write more code on leetcode like platform&lt;/li&gt;
  &lt;li&gt;Write down what I have learned everyday&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/17/Study-Plan/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/17/Study-Plan/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Git 基础使用</title>
        <description>&lt;p&gt;#获取Git仓库&lt;/p&gt;

&lt;p&gt;###方法一：现有目录初始化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init // 初始化
git add *.c // 跟踪文件
git add LICENCSE // 跟踪文件
git commit -m &#39;initial project version&#39; // 提交
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###方法二：克隆现有仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/libgit2/libgit2 // 当前目录下穿件libgit2目录，并将其初始化，拷贝数据到其中
git clone https://github.com/libgit2/libgit2 mylibgit // clone是改名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#记录更新到仓库&lt;/p&gt;

&lt;p&gt;###检查当前文件状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###跟踪新文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###暂存已修改文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每次修改文件都要用add命令再次暂存这个文件&lt;/p&gt;

&lt;p&gt;###文件简要状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git status -s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###忽略文件&lt;/p&gt;

&lt;p&gt;.gitignore文件中列举要忽略文件模式&lt;/p&gt;

&lt;p&gt;###查看修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git diff // 查看尚未暂存的修改
git diff --staged // 查看已暂存，即将提交的修改
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###提交更新&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit // 打开vim输入提交说明
git commit -m &#39;fix some bugs&#39; // 直接输入提交说明
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###跳过暂存&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit -a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时无需讲所有改动暂存，也会将改动提交&lt;/p&gt;

&lt;p&gt;###移除文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm README // 从本地删除文件
git rm README // 从跟踪文件清单中移除
git rm --cached README // 从仓库中和跟踪文件清单中移除，但无须从本地删除
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###移动文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git mv README.md README // 等于下面三条命令
mv README.md README
git rm README.md
git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#查看提交历史&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#撤销操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit -m &#39;initial commit&#39;
git add forgotten_file
git commit --amend // 漏掉文件没有添加的补救方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###取消暂存的文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add README
git reset README // 取消对README的暂存
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#远程仓库的使用&lt;/p&gt;

&lt;p&gt;远程仓库指托管在因特网上的项目的版本库，可以有好几个远程仓库。&lt;/p&gt;

&lt;p&gt;###查看远程仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote
git remote -v // 显示出URL
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###添加远程仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote add pb https://github.com/pauboone/ticgit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加一个新的远程Git仓库，并制定一个简写git remote add &lt;shortname&gt; &lt;url&gt;&lt;/url&gt;&lt;/shortname&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git fetch pb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个命令会访问远程仓库，拉取本地还没有的数据，但不会合并或修改当前工作&lt;/p&gt;

&lt;p&gt;###推送到远程仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之前没人推送过才可以，否则需要先pull再push&lt;/p&gt;

&lt;p&gt;###查看远程仓库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###远程仓库移除和重命名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote rename pb paul // 重命名
git remote rm paul // 移除
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#打标签&lt;/p&gt;

&lt;p&gt;###列出标签&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git tag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###创建标签&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git tag -a v1.4 -m &#39;my version 1.4&#39; // -a选项
git show v1.4 //显示tagv1.4有关信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###共享标签&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push origin v1.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###检出标签&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout -b version2 v2.0.0 // git checkout -b [branchname] [tagname]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/17/Git-Study/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/17/Git-Study/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode Problem 236 Summary</title>
        <description>&lt;p&gt;#题目描述&lt;/p&gt;

&lt;p&gt;输入一棵树，给出根结点和两个结点p和q，需要输出p和q的公共祖先，如果p是q的祖先则直接输出p。&lt;/p&gt;

&lt;p&gt;#思路&lt;/p&gt;

&lt;p&gt;recursion方法十分简单，我们只需找到根结点左子树中p和q的公共祖先情况，右子树中p和q的公共祖先情况，然后进行总结即可：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当递归到p或q时返回当前结点&lt;/li&gt;
  &lt;li&gt;当左右子树返回都为null时说明左右子树均不含p和q，此时我们返回null&lt;/li&gt;
  &lt;li&gt;当左右子树中一个为null，另一个不为null时说明其中一个至少含有p或q中的一个结点，返回那个不为null的结点&lt;/li&gt;
  &lt;li&gt;当两个子树均不为null时，说明p和q一个在左子树，一个在右子树，则我们需要返回root结点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#Java代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 	* Definition for a binary tree node.
 	* public class TreeNode {
 	*     int val;
 	*     TreeNode left;
 	*     TreeNode right;
 	*     TreeNode(int x) { val = x; }
 	* }
 	*/
public class Solution {
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    	if (root == null || root == p || root == q) {
        	return root;
    	}
    	TreeNode leftNode = lowestCommonAncestor(root.left, p, q);
    	TreeNode rightNode = lowestCommonAncestor(root.right, p, q);
    	if (leftNode == null) {
        	return rightNode;
    	} else {
        	if (rightNode == null) {
            	return leftNode;
        	} else {
            	return root;
        	}
    	}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 06 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/06/Leetcode-236-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/06/Leetcode-236-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Javascript Callback Understanding</title>
        <description>&lt;p&gt;#回调函数定义&lt;/p&gt;

&lt;p&gt;回调函数是指一个函数作为参数传入另一个函数中，并在其中执行。常见的JQuery中的回调函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;#button&quot;).click(function({
    alert(&quot;Button Clicked&quot;);
}))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上面代码所展示的，我们把一个函数作为参数传入click函数中，click函数会调用这个传入的函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var friends = [&quot;Mike&quot;, &quot;Stacy&quot;, &quot;Andy&quot;, &quot;Rick&quot;];

friends.forEach(function(eachName, index){
    console.log(index + 1 + &quot;.&quot; + eachName);
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，上面代码中，我们传递了一个匿名函数作为forEach的参数&lt;/p&gt;

&lt;p&gt;#回调函数运行原理&lt;/p&gt;

&lt;p&gt;我们可以把函数作为参数传递，可以作为返回值，可以在其他函数中调用。当我们把函数作为参数传递的时候，我们并没有执行这个函数，而是把函数的定义作为参数进行了传递，因此这个函数可以在之后的任何时间点执行。&lt;/p&gt;

&lt;p&gt;#使用回调函数的基本原则&lt;/p&gt;

&lt;p&gt;###可以使用命名或匿名函数作为回调函数&lt;/p&gt;

&lt;p&gt;最开始的代码是匿名函数的例子，这里给一个命名函数的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var allUserData = [];

function logStuff(userData) {
    if (typeof userData === &quot;string&quot;) {
        console.log(userData);
    } else if (typeof userData === &quot;object&quot;) {
        for (var item in userData) {
            console.log(item + &quot;.&quot; + userData[item]);
        }
    }
}

function getInput(options, callback) {
    allUserData.push(options);
    callback(options);
}

getInput({name:&quot;Rich&quot;,speciality:&quot;JavaScript&quot;}, logStuff);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###可以传递参数到回调函数中&lt;/p&gt;

&lt;p&gt;如上面的例子，我们把options传到callback中&lt;/p&gt;

&lt;p&gt;###在回调函数执行前确保参数的确是个函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getInput(options, callback) {
    allUserData.push(options);

    if (typeof callback === &quot;function&quot;) {
        callback(options);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###在回调函数中使用this的问题&lt;/p&gt;

&lt;p&gt;当回调函数中使用this的时候，我们需要修改callback以保持this中的内容不变。否则this可能指向全局window对象，也可能指向包含它的那个函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var clientData = {
    id: 094545,
    fullName: &quot;Not Set&quot;,

    setUserName: function(firstName, lastName) {
        this.fullName = firstName + &quot; &quot; + lastName;
    }
}

fuction getUserInput(firstName, lastName, callback) {
    callback(firstName, lastName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在接下来的代码中，当setUserName被执行的时候，this指向的并不是clientData对象，而是window对象，因为getUserInput是一个全局函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getUserInput(&quot;Barack&quot;, &quot;Obama&quot;, clientData.setUserName);

console.log(clientData.fullName); //Not Set

console.log(window.fullName);// Barack Obama
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以使用&lt;em&gt;Call&lt;/em&gt;或者&lt;em&gt;Apply&lt;/em&gt;函数：用于设置this对象以及向函数传递参数。Call和Apply的第一个参数都是this对象：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getUserInput(firstName, lastName, callback, callbackObj) {
    callback.apply(callbackObj, [firstName, lastName]);
}

getUserInput(&quot;Barack&quot;, &quot;Obama&quot;, clientData.setUserName, clientData);

console.log(clientData.fullName);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码即可改正之前的this指向错误。&lt;/p&gt;

&lt;p&gt;###允许多个回调函数参数&lt;/p&gt;

&lt;p&gt;我们可以在参数中使用多个回调函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function successCallback() {

}

function completeCallback() {

}

function errorCallback() {

}

$.ajax({
    url:&quot;http://fiddle.jshell.net/favicon.png&quot;,
    success:successCallback,
    complete:completeCallback,
    error:errorCallback
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#回调地狱&lt;/p&gt;

&lt;p&gt;即多层回调导致难以追踪代码，代码以任意顺序运行，下面是MongoDB的一个驱动示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var p_client = new Db(&#39;integration_tests_20&#39;, new Server(&quot;127.0.0.1&quot;, 27017, {}), {&#39;pk&#39;:CustomPKFactory});
p_client.open(function(err, p_client) {
    p_client.dropDatabase(function(err, done) {
        p_client.createCollection(&#39;test_custom_key&#39;, function(err, collection) {
            collection.insert({&#39;a&#39;:1}, function(err, docs) {
                collection.find({&#39;_id&#39;:new ObjectID(&quot;aaaaaaaaaaaa&quot;)}, function(err, cursor) {
                    cursor.toArray(function(err, items) {
                        test.assertEquals(1, items.length);
                        p_client.close();
                    });
                });
            });
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不用匿名函数，而是用函数名作为参数&lt;/li&gt;
  &lt;li&gt;模块化&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 01 Apr 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/04/01/Javascript-Callback/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/04/01/Javascript-Callback/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode Problem 34 Summary</title>
        <description>&lt;p&gt;#题目描述&lt;/p&gt;

&lt;p&gt;输入一个有序可重复数组，和一个目标数，寻找目标数在数组中的范围，输出目标数在数组中的起始和终止位置。如果没找到则输出[-1, -1]。例如[5, 7, 7, 8, 8, 10]，目标值是8，则输出[3, 4]。&lt;/p&gt;

&lt;p&gt;#思路&lt;/p&gt;

&lt;p&gt;###二分查找&lt;/p&gt;

&lt;p&gt;整个过程可拆分为两次二分查找，第一次查找起始位置，第二次查找终止位置。时间复杂度为O(logn)。&lt;/p&gt;

&lt;p&gt;#Java代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        int[] range = new int[2];
        range[0] = -1;
        range[1] = -1;
        
        // if target not in the array range, return directly
        if (target &amp;lt; nums[0] || target &amp;gt; nums[high]) {
            return range;
        }
        
        // find starting position first
        while (low &amp;lt;= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] &amp;gt; target) {
                high = mid - 1;
            } else if (nums[mid] &amp;lt; target) {
                low = mid + 1;
            } else {
                if (mid == 0 || nums[mid - 1] != target) {
                    range[0] = mid;
                    break;
                } else {
                    high = mid - 1;
                }
            }
        }

        // if starting point is not found, return directly
        if (range[0] == -1) {
            return range;
        }
        
        // looking for the ending position
        low = 0;
        high = nums.length - 1;
        while (low &amp;lt;= high) {
            int mid = low + (high - low) / 2;
            if (nums[mid] &amp;gt; target) {
                high = mid - 1;
            } else if (nums[mid] &amp;lt; target) {
                low = mid + 1;
            } else {
                if (mid == (nums.length - 1) || nums[mid + 1] != target) {
                    range[1] = mid;
                    break;
                } else {
                    low = mid + 1;
                }
            }
        }
    
        return range;
    }
}        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/03/24/Leetcode-34-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/03/24/Leetcode-34-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode Problem 330 Summary</title>
        <description>&lt;p&gt;#题目描述&lt;/p&gt;

&lt;p&gt;输入一个sorted integer positive array，向里面添加元素使得1到n中的任何数可以被array中的元素和表示。输出所需添加的元素的最小个数。&lt;/p&gt;

&lt;p&gt;#思路&lt;/p&gt;

&lt;p&gt;miss代表当前最小的不确定是否能表示为加和的数，即miss以前的所有数都可以被表示，那么如果我们有miss或加上miss，则miss+(miss-1)的数都可以被以加和形式表示。&lt;/p&gt;

&lt;p&gt;#Java代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Solution {
    public int minPatches(int[] nums, int n) {
        int add = 0, i = 0;
        double miss = 1;
    
        while (miss &amp;lt;= n) {
            if (i &amp;lt; nums.length &amp;amp;&amp;amp; nums[i] &amp;lt;= miss) {
                miss += nums[i++];
            } else {
                miss += miss;
                add++;
            }
        }
        return add;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#注意&lt;/p&gt;

&lt;p&gt;nums[i] &amp;lt;= miss判断是否可以使用已有的数组元素，如果不满足这个条件说明nums[i] &amp;gt; miss，如果此时用miss+nums[i]则会缺失从miss到nums[i]-1间的元素表示。&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 -0400</pubDate>
        <link>http://lisentoday/blog/2016/03/24/Leetcode-330-summary/</link>
        <guid isPermaLink="true">http://lisentoday/blog/2016/03/24/Leetcode-330-summary/</guid>
        
        <category>study</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
